{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"fluent testing for python","body":"## sure `1.0.6` - utility belt for automated testing in python (inspired by [should.js](https://github.com/visionmedia/should.js/) )\r\n[![Build Status](https://secure.travis-ci.org/gabrielfalcao/sure.png)](http://travis-ci.org/gabrielfalcao/sure)\r\n\r\n\r\n# Installing\r\n\r\n    user@machine:~$ [sudo] pip install sure\r\n\r\n# Fluent assertions\r\n\r\n> available only on cpython (no support for Jython, IronPython, PyPy, etc)\r\n\r\nMind-blowing easy and fluent assertions.\r\n\r\n\r\n#### `(number).should.equal(number)`\r\n\r\n```python\r\nimport sure\r\n\r\n(4).should.be.equal(2 + 2)\r\n(7.5).should.eql(3.5 + 4)\r\n(2).should.equal(8 / 4)\r\n\r\n(3).shouldnt.be.equal(5)\r\n```\r\n\r\n#### `{'a': 'collection'}.should.equal({'a': 'collection'})` does deep comparison\r\n\r\n```python\r\n{'foo': 'bar'}.should.equal({'foo': 'bar'})\r\n{'foo': 'bar'}.should.eql({'foo': 'bar'})\r\n{'foo': 'bar'}.must.be.equal({'foo': 'bar'})\r\n\r\n```\r\n\r\n#### `\"A string\".lower().should.equal(\"a string\")` also works\r\n\r\n```python\r\n\"Awesome ASSERTIONS\".lower().split().should.equal(['awesome', 'assertions'])\r\n```\r\n\r\n#### `{iterable}.should.be.empty` applies to any iterable of length 0\r\n\r\n```python\r\n\r\n[].should.be.empty;\r\n{}.should.be.empty;\r\nset().should.be.empty;\r\n\"\".should.be.empty;\r\n().should.be.empty\r\nrange(0).should.be.empty;\r\n\r\n# negate with:\r\n\r\n[1, 2, 3].shouldnt.be.empty;\r\n\"Lincoln de Sousa\".shouldnt.be.empty;\r\n\"Lincoln de Sousa\".should_not.be.empty;\r\n\r\n```\r\n\r\n\r\n#### `{number}.should.be.within(0, 10)` asserts inclusive numeric range:\r\n\r\n```python\r\n(1).should.be.within(0, 2)\r\n(5).should.be.within(10)\r\n\r\n# negate with:\r\n\r\n(1).shouldnt.be.within(5, 6)\r\n```\r\n\r\n#### `{member}.should.be.within({iterable})` asserts that a member is part of the iterable:\r\n\r\n```python\r\n\"g\".should.be.within(\"gabriel\")\r\n'name'.should.be.within({'name': 'Gabriel'})\r\n'Lincoln'.should.be.within(['Lincoln', 'Gabriel'])\r\n\r\n# negate with:\r\n\r\n'Bug'.shouldnt.be.within(['Sure 1.0'])\r\n'Bug'.should_not.be.within(['Sure 1.0'])\r\n\r\n```\r\n\r\n#### `should.be.none` and `should_not.be.none`\r\n\r\nAssert whether an object is or not `None`:\r\n\r\n```python\r\n\r\nvalue = None\r\nvalue.should.be.none\r\nNone.should.be.none\r\n\r\n\"\".should_not.be.none\r\n(not None).should_not.be.none\r\n\r\n```\r\n\r\n#### `should.be.ok` and `shouldnt.be.ok`\r\n\r\nAssert truthfulness:\r\n\r\n```python\r\nfrom sure import this\r\n\r\nTrue.should.be.ok\r\n'truthy string'.should.be.ok\r\n{'truthy': 'dictionary'}.should.be.ok\r\n```\r\n\r\nAnd negate truthfulness:\r\n\r\n```python\r\n\r\nfrom sure import this\r\n\r\nFalse.shouldnt.be.ok\r\n''.should_not.be.ok\r\n{}.shouldnot.be.ok\r\n```\r\n\r\n#### Assert existence of properties and its values\r\n\r\n```python\r\n\r\nclass Basket(object):\r\n    fruits = [\"apple\", \"banana\"]\r\n\r\n\r\nbasket1 = Basket()\r\n\r\nbasket1.should.have.property(\"fruits\")\r\n```\r\n\r\n##### .have.property().being allows chaining up\r\n\r\nIf the programmer calls `have.property()` it returns an assertion\r\nbuilder of the property if it exists, so that you can chain up\r\nassertions for the property value itself.\r\n\r\n```python\r\n\r\nclass Basket(object):\r\n    fruits = [\"apple\", \"banana\"]\r\n\r\nbasket2 = Basket()\r\nbasket2.should.have.property(\"fruits\").being.equal([\"apple\", \"banana\"])\r\nbasket2.should.have.property(\"fruits\").with_value.equal([\"apple\", \"banana\"])\r\nbasket2.should.have.property(\"fruits\").with_value.being.equal([\"apple\", \"banana\"])\r\n```\r\n\r\n\r\n#### Assert existence of keys and its values\r\n\r\n```python\r\nbasket3 = dict(fruits=[\"apple\", \"banana\"])\r\nbasket3.should.have.key(\"fruits\")\r\n```\r\n\r\n##### .have.key().being allows chaining up\r\n\r\nIf the programmer calls `have.key()` it returns an assertion\r\nbuilder of the key if it exists, so that you can chain up\r\nassertions for the dictionary key value itself.\r\n\r\n\r\n```python\r\n\r\nperson = dict(name=None)\r\n\r\nperson.should.have.key(\"name\").being.none\r\nperson.should.have.key(\"name\").being.equal(None)\r\n```\r\n\r\n#### Assert the length of objects with `{iterable}.should.have.length_of(N)`\r\n\r\n```python\r\n\r\n[3, 4].should.have.length_of(2)\r\n\r\n\"Python\".should.have.length_of(6)\r\n\r\n{'john': 'person'}.should_not.have.length_of(2)\r\n```\r\n\r\n#### Assert the magnitude of objects with `{X}.should.be.greater_than(Y)` and `{Y}.should.be.lower_than(X)`\r\n\r\n```python\r\n(5).should.be.greater_than(4)\r\n(5).should_not.be.greater_than(10)\r\n(1).should.be.lower_than(2)\r\n(1).should_not.be.lower_than(0)\r\n```\r\n\r\n#### `callable.when.called_with(arg1, kwarg1=2).should.throw(Exception)`\r\n\r\nYou can use this feature to assert that a callable raises an\r\nexception:\r\n\r\n```python\r\nimport sure\r\n\r\nrange.when.called_with(10, step=\"20\").should.throw(TypeError, \"range() takes no keyword arguments\")\r\nrange.when.called_with(\"chuck norris\").should.throw(\"range() integer end argument expected, got str.\")\r\nrange.when.called_with(\"chuck norris\").should.throw(TypeError)\r\nrange.when.called_with(10).should_not.throw(TypeError)\r\n```\r\n\r\n#### `function.when.called_with(arg1, kwarg1=2).should.return_value(value)`\r\n\r\nThis is a shorthand for testing that a callable returns the expected\r\nresult\r\n\r\n```python\r\nimport sure\r\n\r\nrange.when.called_with(2).should.return_value([0, 1])\r\n```\r\n\r\nthis is the same as\r\n\r\n```\r\nvalue = range(2)\r\nvalue.should.equal([0, 1])\r\n```\r\n\r\nthere are no differences between those 2 possibilities, use at will\r\n\r\n#### `instance.should.be.a('typename')` and `instance.should.be.an('typename')`\r\n\r\nthis takes a type name and checks if the class matches that name\r\n\r\n```python\r\nimport sure\r\n\r\n{}.should.be.a('dict')\r\n(5).should.be.an('int')\r\n\r\n# also works with paths\r\n\r\nrange(10).should.be.a('collections.Iterable')\r\n```\r\n\r\n#### `instance.should.be.a(type)` and `instance.should.be.an(type)`\r\n\r\nthis takes the class (type) itself and checks if the object is an instance of it\r\n\r\n```python\r\nimport sure\r\n\r\nu\"\".should.be.an(unicode)\r\n[].should.be.a(list)\r\n```\r\n\r\n#### `instance.should.be.above(num)` and `instance.should.be.below(num)`\r\n\r\nassert the instance value above and below `num`\r\n\r\n```python\r\nimport sure\r\n\r\n(10).should.be.below(11)\r\n(10).should.be.above(9)\r\n(10).should_not.be.above(11)\r\n(10).should_not.be.below(9)\r\n```\r\n\r\n\r\n# Static assertions with `it`, `this`, `those` and `these`\r\n\r\nWhether you don't like the `object.should` syntax or you are simply\r\nnot running CPython, sure still allows you to use any of the\r\nassertions above, all you need to do is wrap the object that is being\r\ncompared in one of the following options: `it`, `this`, `those` and\r\n`these`.\r\n\r\n## Too long, don't read\r\n\r\n### All those possibilities below work just as the same\r\n\r\n```python\r\nfrom sure import it, this, those, these\r\n\r\n(10).should.be.equal(5 + 5)\r\n\r\nthis(10).should.be.equal(5 + 5)\r\n\r\nit(10).should.be.equal(5 + 5)\r\n\r\nthese(10).should.be.equal(5 + 5)\r\n\r\nthose(10).should.be.equal(5 + 5)\r\n```\r\n\r\n### Also if you prefer using the `assert` keyword in your tests just go ahead an do it!\r\n\r\n```python\r\nfrom sure import it, this, those, these, expect\r\n\r\nassert (10).should.be.equal(5 + 5)\r\n\r\nassert this(10).should.be.equal(5 + 5)\r\n\r\nassert it(10).should.be.equal(5 + 5)\r\n\r\nassert these(10).should.be.equal(5 + 5)\r\n\r\nassert those(10).should.be.equal(5 + 5)\r\n\r\nexpect(10).to.be.equal(5 + 5)\r\nexpect(10).to.not_be.equal(8)\r\n```\r\n\r\n#### `(lambda: None).should.be.callable`\r\n\r\nTest if something is or not callable\r\n\r\n```python\r\nimport sure\r\n\r\nrange.should.be.callable\r\n(lambda: None).should.be.callable;\r\n(123).should_not.be.callable\r\n```\r\n\r\n### A note about the `assert` keyword\r\n\r\n_you can use or not the_ `assert` _keyword, sure internally already\r\nraises an appropriate_ `AssertionError` _with an assertion message so\r\nthat you don't have to specify your own, but you can still use_\r\n`assert` _if you find it more semantic_\r\n\r\nExample:\r\n\r\n```python\r\nimport sure\r\n\r\n\"Name\".lower().should.equal('name')\r\n\r\n# or you can also use\r\n\r\nassert \"Name\".lower().should.equal('name')\r\n\r\n# or still\r\n\r\nfrom sure import this\r\n\r\nassert this(\"Name\".lower()).should.equal('name')\r\n\r\n# also without the `assert`\r\n\r\nthis(\"Name\".lower()).should.equal('name')\r\n\r\n```\r\n\r\nAny of the examples above will raise their own `AssertionError` with a\r\nmeaningful error message.\r\n\r\n# Synonyms\r\n\r\nSure provides you with a lot of synonyms so that you can pick the ones\r\nthat makes more sense for your tests.\r\n\r\nNote that the examples below are merely illustrative, they work not\r\nonly with numbers but with any of the assertions you read early in\r\nthis documentation.\r\n\r\n## Positive synonyms\r\n\r\n```python\r\n\r\n(2 + 2).should.be.equal(4)\r\n(2 + 2).must.be.equal(4)\r\n(2 + 2).does.equals(4)\r\n(2 + 2).do.equals(4)\r\n```\r\n\r\n## Negative synonyms\r\n\r\n```python\r\nfrom sure import expect\r\n\r\n(2).should_not.be.equal(3)\r\n(2).shouldnt.be.equal(3)\r\n(2).doesnt.equals(3)\r\n(2).does_not.equals(3)\r\n(2).doesnot.equals(3)\r\n(2).dont.equal(3)\r\n(2).do_not.equal(3)\r\n\r\nexpect(3).to.not_be.equal(1)\r\n```\r\n\r\n## Chain-up synonyms\r\n\r\nAny of those synonyms work as an alias to the assertion builder:\r\n\r\n* `be`\r\n* `being`\r\n* `to`\r\n* `when`\r\n* `have`\r\n* `with_value`\r\n\r\n```python\r\nfrom sure import expect\r\n\r\n{\"foo\": 1}.must.with_value.being.equal({\"foo\": 1})\r\n{\"foo\": 1}.does.have.key(\"foo\").being.with_value.equal(1)\r\n```\r\n\r\n## Equality synonyms\r\n\r\n```python\r\n\r\n(2).should.equal(2)\r\n(2).should.equals(2)\r\n(2).should.eql(2)\r\n```\r\n\r\n## Positive boolean synonyms\r\n\r\n```python\r\n\r\n(not None).should.be.ok\r\n(not None).should.be.truthy\r\n(not None).should.be.true\r\n```\r\n\r\n## Negative boolean synonyms\r\n\r\n```python\r\nFalse.should.be.falsy\r\nFalse.should.be.false\r\nFalse.should_not.be.true\r\nFalse.should_not.be.ok\r\nNone.should_not.be.true\r\nNone.should_not.be.ok\r\n```\r\n\r\n# Can I disable those the new syntax by default ?\r\n\r\nSure! :+1:\r\n\r\nJust export the `SURE_DISABLE_NEW_SYNTAX` environment variable before\r\nrunning your tests.\r\n\r\n```console\r\nexport SURE_DISABLE_NEW_SYNTAX=True\r\n```\r\n# Python compatibility\r\n\r\n## Those are the python versions that support the assertions above [`CPython`](http://en.wikipedia.org/wiki/CPython)\r\n\r\n\r\n```\r\n\r\nPython ~= 2.6 (CPython)\r\nPython ~= 2.7 (CPython)\r\n\r\n```\r\n\r\n## Not supported:\r\n\r\n```\r\n\r\nJython\r\n\r\nPyPy\r\n\r\nIronPython\r\n\r\nUnladenSwallow\r\n\r\nStacklessPython\r\n\r\n...\r\n```\r\n\r\n## Why CPython-only ?\r\n\r\nSure has a slick algorithm that makes use of the\r\n[ctypes](http://docs.python.org/library/ctypes), and although it is\r\nalso available in other implementations such as\r\n[Jython](http://www.jython.org/) does have the `ctypes` module, only\r\nthe CPython provides\r\n[`ctypes.pythonapi`](http://docs.python.org/library/ctypes#loading-shared-libraries),\r\nrequired by sure.\r\n\r\n### Holy guacamole, how did you implement that feature ?\r\n\r\nDifferently of [ruby](http://www.ruby-lang.org) python doesn't have\r\n[open classes](http://blog.aizatto.com/2007/06/01/ruby-and-open-classes/),\r\nbut [Lincoln de Sousa](https://github.com/clarete/) came out with a\r\nsuper [sick code](https://github.com/gabrielfalcao/sure/blob/master/sure/magic.py) that uses the ctypes module to create a pointer to the\r\n`__dict__` of builtin types.\r\n\r\nYes, it is dangerous, non-pythonic and should not be used in production code.\r\n\r\nAlthough `sure` is here to be used __ONLY__ in test code, therefore it\r\nshould be running in __ONLY__ possible environments: your local\r\nmachine or your continuous-integration server.\r\n\r\n# About sure 1.0\r\n\r\nThe assertion library is 100% inspired be the awesomeness of\r\n[should.js](https://github.com/visionmedia/should.js) which is simple,\r\ndeclarative and fluent.\r\n\r\nSure strives to provide everything a python developer needs in an assertion:\r\n\r\n* Assertion messages are easy to understand\r\n\r\n* When comparing iterables the comparation is recursive and shows\r\n  exactly where is the error\r\n\r\n* Fluency: the builtin types are changed in order to provide awesome\r\n  simple assertions\r\n\r\n# Old API\r\n\r\nSure still provides to all the assertions from v0.10 up, you can [find the old documentation here](https://github.com/gabrielfalcao/sure/blob/master/OLD_API.md)\r\n\r\n## Authors\r\n\r\n[Gabriel Falcão](http://github.com/gabrielfalcao) and [Lincoln Clarete](http://github.com/clarete)\r\n\r\n\r\n# License (GPLv3)\r\n\r\n\r\n    Copyright (C) <2012>  Gabriel Falcão <gabriel@nacaolivre.org>\r\n    Copyright (C) <2012>  Lincoln Clarete <lincoln@comum.org>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n","name":"Sure","google":"UA-1277640-11"}